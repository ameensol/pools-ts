"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.poseidon = void 0;
// original source: https://github.com/iden3/circomlib/blob/v0.5.5/src/poseidon.js
const bignumber_1 = require("@ethersproject/bignumber");
// taken from https://github.com/iden3/fastfile
function unstringifyBigInts(o) {
    if (typeof o == 'string' &&
        (/^[0-9]+$/.test(o) || /^0x[0-9a-fA-F]+$/.test(o))) {
        return BigInt(o);
    }
    else if (Array.isArray(o)) {
        return o.map(unstringifyBigInts);
    }
    else if (typeof o == 'object' && !o._isBigNumber) {
        if (o === null)
            return null;
        const res = {};
        Object.keys(o).forEach((k) => {
            res[k] = unstringifyBigInts(o[k]);
        });
        return res;
    }
    else {
        return o;
    }
}
// Parameters are generated by a reference script https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/generate_parameters_grain.sage
// Used like so: sage generate_parameters_grain.sage 1 0 254 2 8 56 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001
const poseidon_constants_opt_json_1 = __importDefault(require("./poseidon_constants_opt.json"));
const opt = unstringifyBigInts(poseidon_constants_opt_json_1.default);
// Using recommended parameters from whitepaper https://eprint.iacr.org/2019/458.pdf (table 2, table 8)
// Generated by https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/calc_round_numbers.py
// And rounded up to nearest integer that divides by t
const N_ROUNDS_F = 8;
const N_ROUNDS_P = [
    56, 57, 56, 60, 60, 63, 64, 63, 60, 66, 60, 65, 70, 60, 64, 68
];
const common_1 = require("./common");
function toBN(a) {
    return BigInt(a._hex);
}
const p = toBN(common_1.P);
const z = toBN(common_1.ZERO);
function add(a, b) {
    return (a + b) % p;
}
function mul(a, b) {
    return (a * b) % p;
}
function square(a) {
    return (a * a) % p;
}
function pow5(a) {
    return mul(a, square(square(a)));
}
function normalize(a) {
    a = bignumber_1.BigNumber.from(a);
    return a.lt(0) ? common_1.P.sub(bignumber_1.BigNumber.from(-a).mod(common_1.P)) : a.mod(common_1.P);
}
function poseidon(inputs, numOutputs) {
    if (typeof numOutputs === 'undefined') {
        numOutputs = 1;
    }
    if (typeof numOutputs !== 'number') {
        throw new Error('Invalid numOutputs: expected a number');
    }
    else if (numOutputs < 1 || numOutputs > 16) {
        throw new Error('Invalid numOutputs: expected 1 <= numOutputs <= 16');
    }
    if (!Array.isArray(inputs)) {
        throw new Error('Invalid inputs: expected an array');
    }
    else if (inputs.length == 0 || inputs.length > N_ROUNDS_P.length) {
        throw new Error(`Invalid inputs length. Expected 0 < inputs.length <= ${N_ROUNDS_P.length}.`);
    }
    const t = inputs.length + 1;
    const nRoundsF = N_ROUNDS_F;
    const nRoundsP = N_ROUNDS_P[t - 2];
    const C = opt.C[t - 2];
    const S = opt.S[t - 2];
    const M = opt.M[t - 2];
    const P = opt.P[t - 2];
    let state = [z, ...inputs.map((a) => toBN(normalize(a)))];
    state = state.map((a, i) => add(a, C[i]));
    for (let r = 0; r < nRoundsF / 2 - 1; r++) {
        state = state.map((a) => pow5(a));
        state = state.map((a, i) => add(a, C[(r + 1) * t + i]));
        state = state.map((_, i) => state.reduce((acc, a, j) => add(acc, mul(M[j][i], a)), z));
    }
    state = state.map((a) => pow5(a));
    state = state.map((a, i) => add(a, C[(nRoundsF / 2 - 1 + 1) * t + i]));
    state = state.map((_, i) => state.reduce((acc, a, j) => add(acc, mul(P[j][i], a)), z));
    for (let r = 0; r < nRoundsP; r++) {
        state[0] = pow5(state[0]);
        state[0] = add(state[0], C[(nRoundsF / 2 + 1) * t + r]);
        const s0 = state.reduce((acc, a, j) => {
            return add(acc, mul(S[(t * 2 - 1) * r + j], a));
        }, z);
        for (let k = 1; k < t; k++) {
            state[k] = add(state[k], mul(state[0], S[(t * 2 - 1) * r + t + k - 1]));
        }
        state[0] = s0;
    }
    for (let r = 0; r < nRoundsF / 2 - 1; r++) {
        state = state.map((a) => pow5(a));
        state = state.map((a, i) => add(a, C[(nRoundsF / 2 + 1) * t + nRoundsP + r * t + i]));
        state = state.map((_, i) => state.reduce((acc, a, j) => add(acc, mul(M[j][i], a)), z));
    }
    state = state.map((a) => pow5(a));
    state = state.map((_, i) => state.reduce((acc, a, j) => add(acc, mul(M[j][i], a)), z));
    if (numOutputs > 1) {
        return state.slice(0, numOutputs).map(normalize);
    }
    else {
        return normalize(state[0]);
    }
}
exports.poseidon = poseidon;
