// original source: https://github.com/iden3/circomlib/blob/v0.5.5/src/poseidon.js
import { BigNumberish, BigNumber } from '@ethersproject/bignumber';

// taken from https://github.com/iden3/fastfile
function unstringifyBigInts(o: any): any {
    if (
        typeof o == 'string' &&
        (/^[0-9]+$/.test(o) || /^0x[0-9a-fA-F]+$/.test(o))
    ) {
        return BigInt(o);
    } else if (Array.isArray(o)) {
        return o.map(unstringifyBigInts);
    } else if (typeof o == 'object' && !o._isBigNumber) {
        if (o === null) return null;
        const res: { [index: string]: any } = {};
        Object.keys(o).forEach((k) => {
            res[k] = unstringifyBigInts(o[k]);
        });
        return res;
    } else {
        return o;
    }
}

// Parameters are generated by a reference script https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/generate_parameters_grain.sage
// Used like so: sage generate_parameters_grain.sage 1 0 254 2 8 56 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001
import constants from './poseidon_constants_opt.json';
const opt = unstringifyBigInts(constants);
// Using recommended parameters from whitepaper https://eprint.iacr.org/2019/458.pdf (table 2, table 8)
// Generated by https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/calc_round_numbers.py
// And rounded up to nearest integer that divides by t
const N_ROUNDS_F = 8;
const N_ROUNDS_P = [
    56, 57, 56, 60, 60, 63, 64, 63, 60, 66, 60, 65, 70, 60, 64, 68
];

import { P, ZERO } from './common';

function toBN(a: BigNumber): bigint {
    return BigInt(a._hex);
}

const p = toBN(P);
const z = toBN(ZERO);

function add(a: bigint, b: bigint): bigint {
    return (a + b) % p;
}

function mul(a: bigint, b: bigint): bigint {
    return (a * b) % p;
}

function square(a: bigint): bigint {
    return (a * a) % p;
}

function pow5(a: bigint): bigint {
    return mul(a, square(square(a)));
}

function normalize(a: BigNumberish): BigNumber {
    a = BigNumber.from(a);
    return a.lt(0) ? P.sub(BigNumber.from(-a).mod(P)) : a.mod(P);
}

type NumOutputs =
    | typeof undefined
    | 1
    | 2
    | 3
    | 4
    | 5
    | 6
    | 7
    | 8
    | 9
    | 10
    | 11
    | 12
    | 13
    | 14
    | 15
    | 16;
type PoseidonOutput<T> = T extends Exclude<NumOutputs, 1 | typeof undefined>
    ? BigNumber[]
    : BigNumber;

export function poseidon<T extends NumOutputs>(
    inputs: BigNumberish[] | BigNumber[],
    numOutputs?: T
): PoseidonOutput<T> {
    if (typeof numOutputs === 'undefined') {
        numOutputs = 1 as T;
    }
    if (typeof numOutputs !== 'number') {
        throw new Error('Invalid numOutputs: expected a number');
    } else if (numOutputs < 1 || numOutputs > 16) {
        throw new Error('Invalid numOutputs: expected 1 <= numOutputs <= 16');
    }

    if (!Array.isArray(inputs)) {
        throw new Error('Invalid inputs: expected an array');
    } else if (inputs.length == 0 || inputs.length > N_ROUNDS_P.length) {
        throw new Error(
            `Invalid inputs length. Expected 0 < inputs.length <= ${N_ROUNDS_P.length}.`
        );
    }

    const t = inputs.length + 1;
    const nRoundsF = N_ROUNDS_F;
    const nRoundsP = N_ROUNDS_P[t - 2];
    const C = opt.C[t - 2];
    const S = opt.S[t - 2];
    const M = opt.M[t - 2];
    const P = opt.P[t - 2];
    let state = [z, ...inputs.map((a) => toBN(normalize(a)))];
    state = state.map((a, i) => add(a, C[i]));
    for (let r = 0; r < nRoundsF / 2 - 1; r++) {
        state = state.map((a) => pow5(a));
        state = state.map((a, i) => add(a, C[(r + 1) * t + i]));
        state = state.map((_, i) =>
            state.reduce((acc, a, j) => add(acc, mul(M[j][i], a)), z)
        );
    }
    state = state.map((a) => pow5(a));
    state = state.map((a, i) => add(a, C[(nRoundsF / 2 - 1 + 1) * t + i]));
    state = state.map((_, i) =>
        state.reduce((acc, a, j) => add(acc, mul(P[j][i], a)), z)
    );
    for (let r = 0; r < nRoundsP; r++) {
        state[0] = pow5(state[0]);
        state[0] = add(state[0], C[(nRoundsF / 2 + 1) * t + r]);
        const s0 = state.reduce((acc, a, j) => {
            return add(acc, mul(S[(t * 2 - 1) * r + j], a));
        }, z);
        for (let k = 1; k < t; k++) {
            state[k] = add(
                state[k],
                mul(state[0], S[(t * 2 - 1) * r + t + k - 1])
            );
        }
        state[0] = s0;
    }
    for (let r = 0; r < nRoundsF / 2 - 1; r++) {
        state = state.map((a) => pow5(a));
        state = state.map((a, i) =>
            add(a, C[(nRoundsF / 2 + 1) * t + nRoundsP + r * t + i])
        );
        state = state.map((_, i) =>
            state.reduce((acc, a, j) => add(acc, mul(M[j][i], a)), z)
        );
    }
    state = state.map((a) => pow5(a));
    state = state.map((_, i) =>
        state.reduce((acc, a, j) => add(acc, mul(M[j][i], a)), z)
    );

    if (numOutputs > 1) {
        return state.slice(0, numOutputs).map(normalize) as PoseidonOutput<T>;
    } else {
        return normalize(state[0]) as PoseidonOutput<T>;
    }
}
